import streamlit as st
import networkx as nx
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from scipy.linalg import expm

# --- 1. KONFIGURATION (Muss ganz oben stehen) ---
st.set_page_config(
    page_title="SDRIS Framework Simulation Pro", 
    page_icon="ðŸŒŒ",
    layout="wide"
)

# Custom CSS
st.markdown("""
<style>
    .stApp { background-color: #0E1117; }
    h1, h2, h3 { color: #00ccff !important; font-family: 'Helvetica Neue', sans-serif; }
    .stButton>button { border-radius: 20px; border: 1px solid #00ccff; color: #00ccff; background: transparent; }
    .stButton>button:hover { background: #00ccff; color: #000; border: 1px solid #00ccff; }
</style>
""", unsafe_allow_html=True)

st.title("ðŸŒŒ SDRIS Theory: Interactive Verification v2.0")
st.markdown("""
**Static-Dynamic Recursive Information Space**
Dieses Dashboard visualisiert die vier SÃ¤ulen der Theorie. Optimierte Berechnungskerne und interaktive Graphen.
""")

# --- 2. RECHENKERNE (FUNKTIONEN) ---

@st.cache_data
def simulate_universe_structure(steps, p_fork, p_link):
    """Generiert das Raum-Zeit-Netzwerk."""
    G = nx.Graph()
    root = "0"
    G.add_node(root, layer=0)
    active_nodes = [root]
    
    for t in range(steps):
        new_nodes = []
        for node in active_nodes:
            if random.random() < p_fork:
                for i in range(2): 
                    child = f"{node}.{i}"
                    G.add_node(child, layer=t+1)
                    G.add_edge(node, child, type='time')
                    new_nodes.append(child)
        
        if len(new_nodes) > 0:
            potential = new_nodes if len(new_nodes) < 50 else random.sample(new_nodes, 50)
            for n1 in new_nodes:
                for n2 in potential:
                    if n1 == n2: continue
                    if random.random() < p_link: 
                        G.add_edge(n1, n2, type='space')
        
        if new_nodes: active_nodes = new_nodes
    return G

@st.cache_data
def simulate_flux_tunnel_dynamics(n_dim, damping_type, base_rate, steps=40):
    """Entropic Dynamics."""
    J = np.zeros((n_dim, n_dim), dtype=complex)
    idx = np.arange(n_dim - 1)
    J[idx, idx+1] = -1j
    J[idx+1, idx] = 1j
    
    evals, evecs = np.linalg.eigh(J)
    
    np.random.seed(42)
    psi = np.random.rand(n_dim) + 1j * np.random.rand(n_dim)
    psi = psi / np.linalg.norm(psi)
    
    t_vals = []
    norms = []
    dt = 0.1
    
    U = expm(-1j * J * dt)
    current_psi = psi.copy()
    
    for t in range(steps + 1):
        norm = np.linalg.norm(current_psi)
        norms.append(norm)
        t_vals.append(t * dt)
        
        # A. Unitary Step
        current_psi = U @ current_psi
        
        # B. Damping Step
        if damping_type == 'Constant':
            decay = np.exp(-base_rate * dt)
            current_psi = current_psi * decay
        elif damping_type == 'Eigen-Dependent':
            coeffs = evecs.conj().T @ current_psi
            decay_factors = np.exp(-base_rate * np.abs(evals) * dt)
            coeffs = coeffs * decay_factors
            current_psi = evecs @ coeffs
            
    return t_vals, norms

@st.cache_data
def get_vacuum_spectrum_optimized(num_primes, f_max):
    """Vektorisierte Berechnung (High Performance)."""
    limit = int(num_primes * 15)
    is_prime = np.ones(limit, dtype=bool)
    is_prime[:2] = False
    for i in range(2, int(limit**0.5) + 1):
        if is_prime[i]:
            is_prime[i*i:limit:i] = False
    
    primes = np.nonzero(is_prime)[0][:num_primes]
    
    freqs = np.linspace(0.1, f_max, 1000)
    p_arr = primes.reshape(1, -1)
    f_arr = freqs.reshape(-1, 1)
    
    log_p = np.log(p_arr)
    inv_sqrt_p = 1.0 / np.sqrt(p_arr)
    
    args = 2 * np.pi * f_arr * log_p
    cos_terms = np.cos(args)
    weighted_cos = cos_terms * (log_p * inv_sqrt_p)
    amplitudes = np.sum(weighted_cos, axis=1)
    psd = (1/freqs) * (amplitudes**2)
    
    return freqs, psd

# --- 3. SIDEBAR ---
st.sidebar.header("ðŸŽ›ï¸ SDRIS Control Center")

with st.sidebar.expander("1. Geometrie Parameter", expanded=True):
    p_fork = st.slider("Zeit-Expansion (Fork)", 0.5, 1.0, 0.90)
    p_link = st.slider("Raum-Dichte (Link)", 0.01, 0.5, 0.15)
    steps_geo = st.slider("Simulation Steps", 5, 9, 7)

with st.sidebar.expander("2. SÃ¤ttigung & Entropie"):
    max_dim_view = st.slider("Max Dimension View", 21, 100, 40)
    sim_dim = st.selectbox("Flux Tunnel GrÃ¶ÃŸe", [5, 7, 13, 17, 19, 21, 31], index=1)
    base_rate_input = st.slider("DÃ¤mpfungs-Rate", 0.01, 0.5, 0.08)

with st.sidebar.expander("3. Holographie (High Res)"):
    num_primes = st.slider("Primzahl Tiefe", 100, 5000, 1000)
    freq_max = st.slider("Frequenzbereich", 10, 200, 60)

# --- 4. MAIN TABS ---
tab1, tab2, tab3, tab4 = st.tabs(["1. Geometrie", "2. SÃ¤ttigung", "3. Entropie", "4. Holometer"])

# --- TAB 1: GEOMETRIE ---
with tab1:
    st.header("Emergent Geometry (Axiom I)")
    
    if 'graph_data' not in st.session_state:
        st.session_state.graph_data = None

    col_btn, col_info = st.columns([1, 4])
    with col_btn:
        if st.button("ðŸ”„ Generieren", use_container_width=True) or st.session_state.graph_data is None:
            st.session_state.graph_data = simulate_universe_structure(steps_geo, p_fork, p_link)
    
    G = st.session_state.graph_data
    
    with col_info:
        st.caption(f"Knoten: {G.number_of_nodes()} | Kanten: {G.number_of_edges()}")

    fig, ax = plt.subplots(figsize=(10, 5))
    pos = nx.spring_layout(G, seed=42, iterations=35)
    colors = [G.nodes[n]['layer'] for n in G.nodes()]
    
    nx.draw_networkx_nodes(G, pos, node_size=60, node_color=colors, cmap=plt.cm.cool, ax=ax)
    nx.draw_networkx_edges(G, pos, alpha=0.2, edge_color='#aaaaaa', ax=ax)
    ax.axis('off')
    fig.patch.set_facecolor('#0E1117')
    st.pyplot(fig)

# --- TAB 2: SÃ„TTIGUNG ---
with tab2:
    st.header("Regime Stability & Dimensional Selection")
    
    st.markdown("""
    Warum hat unser Universum **3 Raumdimensionen**? 
    Dieses Modul testet die "Ontologische StabilitÃ¤t" verschiedener Dimensionen N.
    """)

    # 1. Analyse-Parameter
    col_ctrl, col_kpi = st.columns([1, 3])
    with col_ctrl:
        scan_range = st.slider("Scan-Bereich (Dimensionen)", 2, 21, 17)       
        st.info("N=3 ist der vermutete StabilitÃ¤ts-Punkt.")
    
    # 2. Berechnung des Scans
    results = []
    for n in range(2, scan_range + 1):
        J = np.zeros((n, n), dtype=complex)
        idx = np.arange(n - 1)
        J[idx, idx+1] = -1j
        J[idx+1, idx] = 1j
        
        evals = np.linalg.eigvals(J)
        abs_evals = np.sort(np.abs(evals))
        max_tension = np.max(abs_evals)
        
        has_zero = np.any(np.isclose(abs_evals, 0.0, atol=1e-2))
        non_zero_evals = abs_evals[abs_evals > 1e-2]
        gap = np.max(non_zero_evals) - np.min(non_zero_evals) if len(non_zero_evals) > 0 else 0
        
        stability_score = (1.0 / (max_tension * np.log(n))) * (2.0 if not has_zero else 0.5)
        
        results.append({
            "N": n, "Tension": max_tension,
            "ZeroMode": "Ja" if has_zero else "Nein",
            "Gap": gap, "Score": stability_score
        })
    
    df_res = pd.DataFrame(results)

    # 3. Visualisierung
    with col_kpi:
        colors = ['#555555'] * len(df_res)
        if len(colors) > 1: colors[1] = '#00ccff' # N=3
        if len(colors) > 2: colors[2] = '#ff4b4b' # N=4

        fig_dim = go.Figure()
        fig_dim.add_trace(go.Bar(
            x=df_res['N'], y=df_res['Score'],
            marker_color=colors, name='Stability Score',
            text=df_res['ZeroMode'], textposition='auto'
        ))
        fig_dim.add_trace(go.Scatter(
            x=df_res['N'], y=df_res['Tension'],
            mode='lines+markers', name='Ontological Tension',
            line=dict(color='white', dash='dot'), yaxis='y2'
        ))

        fig_dim.update_layout(
            title="Warum 3D? Der StabilitÃ¤ts-Check",
            xaxis_title="Dimension (N)",
            yaxis_title="StabilitÃ¤ts-Score",
            yaxis2=dict(title="Tension", overlaying='y', side='right'),
            template="plotly_dark", height=450, barmode='group'
        )
        st.plotly_chart(fig_dim, use_container_width=True)

    # 4. Interpretation
    st.markdown("### ðŸ§¬ Analyse der Ergebnisse")
    col1, col2 = st.columns(2)
    with col1:
        st.success("**Warum N=3 gewinnt:** N=3 bietet den besten Kompromiss zwischen Freiheitsgraden und IntegritÃ¤t.")
    with col2:
        st.warning("**Problem hÃ¶herer Dimensionen:** Tension steigt, Zero Modes fÃ¼hren zu InstabilitÃ¤t.")

    st.markdown("---")
    st.subheader("ðŸ”¬ RÃ¶ntgenblick: Alle Eigenwerte pro Dimension")
    
    # Heatmap Calculation (Moved here to access scan_range correctly)
    all_evals_data = []
    for n in range(2, scan_range + 1):
        J = np.zeros((n, n), dtype=complex)
        idx = np.arange(n - 1)
        J[idx, idx+1] = -1j
        J[idx+1, idx] = 1j
        evals = np.sort(np.abs(np.linalg.eigvals(J)))
        
        for i, val in enumerate(evals):
            all_evals_data.append({"Dimension_N": n, "Eigenwert_Index": i+1, "Magnitude": val})
            
    df_spectrum = pd.DataFrame(all_evals_data)
    
    fig_spec = go.Figure()
    fig_spec.add_trace(go.Scatter(
        x=df_spectrum['Dimension_N'],
        y=df_spectrum['Magnitude'],
        mode='markers',
        marker=dict(size=6, color=df_spectrum['Magnitude'], colorscale='Viridis', showscale=True),
        text=df_spectrum['Eigenwert_Index'],
        hovertemplate="Dim: %{x}<br>Val: %{y:.3f}<extra></extra>"
    ))
    
    fig_spec.update_layout(
        title="Das volle Spektrum: N Dimensionen erzeugen N Eigenwerte",
        xaxis_title="Dimension des Raumes (N)", yaxis_title="Eigenwert Magnitude |Î»|",
        template="plotly_dark", height=500
    )
    st.plotly_chart(fig_spec, use_container_width=True)

# --- TAB 3: ENTROPIE ---
with tab3:
    st.header("Axiom IV: Entropic Damping Dynamics")
    
    t, norms_const = simulate_flux_tunnel_dynamics(sim_dim, 'Constant', base_rate_input)
    _, norms_eigen = simulate_flux_tunnel_dynamics(sim_dim, 'Eigen-Dependent', base_rate_input)
    
    fig_ent = go.Figure()
    fig_ent.add_trace(go.Scatter(x=t, y=norms_const, name='Constant Damping (Naive)', line=dict(dash='dot', color='gray')))
    fig_ent.add_trace(go.Scatter(x=t, y=norms_eigen, name='Eigen-Dependent (Hawking)', line=dict(color='#ff4b4b', width=3)))
    
    fig_ent.update_layout(
        title=f"Information Loss in Flux Tunnel (Dim={sim_dim})",
        xaxis_title="Time (t)", yaxis_title="Information Norm ||Ïˆ||",
        template="plotly_dark", height=450
    )
    st.plotly_chart(fig_ent, use_container_width=True)
    
    loss_eigen = (1 - norms_eigen[-1]) * 100
    st.metric("Information Loss (t=end)", f"{loss_eigen:.2f}%", delta="-Entropy")

# --- TAB 4: HOLOMETER ---
with tab4:
    st.header("Vacuum Holography (Riemann-Zeta Refined)")
    st.markdown("Verwendet **vektorisierte Guinand-Weil-Transformation** fÃ¼r High-Performance Rausch-Synthese.")
    
    freqs, psd = get_vacuum_spectrum_optimized(num_primes, freq_max)
    
    valid_idx = np.where(psd > 1e-9)
    if len(valid_idx[0]) > 1:
        z = np.polyfit(np.log(freqs[valid_idx]), np.log(psd[valid_idx]), 1)
        p_func = np.poly1d(z)
        trend_y = np.exp(p_func(np.log(freqs)))
    else:
        trend_y = np.zeros_like(freqs)
    
    fig_holo = go.Figure()
    fig_holo.add_trace(go.Scatter(x=freqs, y=psd, name='Quantum Noise', line=dict(color='#ffaa00', width=1), fill='tozeroy'))
    fig_holo.add_trace(go.Scatter(x=freqs, y=trend_y, name=f'Fractal Trend', line=dict(color='white', width=1, dash='dash')))
    
    fig_holo.update_layout(
        title="Spectral Density S(f) [Log-Log]",
        xaxis_type="log", yaxis_type="log",
        xaxis_title="Frequenz (Hz)", yaxis_title="Power Spectral Density",
        template="plotly_dark", height=500
    )
    st.plotly_chart(fig_holo, use_container_width=True)

    col1, col2 = st.columns(2)
    with col1:
        peak_idx = np.argmax(psd)
        st.info(f"**Dominante Resonanz:** {freqs[peak_idx]:.4f} Hz")
    
    with col2:
        export_df = pd.DataFrame({"Frequency": freqs, "PSD": psd})
        st.download_button(
            label="ðŸ’¾ Spektrum als CSV",
            data=export_df.to_csv(index=False).encode('utf-8'),
            file_name="sdris_vacuum_spectrum.csv",
            mime="text/csv"
        )
