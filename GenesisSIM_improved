import streamlit as st
import networkx as nx
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
from scipy.linalg import expm

# --- KONFIGURATION ---
st.set_page_config(
Â  Â  page_title="SDRIS Framework Simulation Pro",Â 
Â  Â  page_icon="ğŸŒŒ",
Â  Â  layout="wide"
)

# Custom CSS fÃ¼r professionelleren Look
st.markdown("""
<style>
Â  Â  .stApp { background-color: #0E1117; }
Â  Â  h1, h2, h3 { color: #00ccff !important; font-family: 'Helvetica Neue', sans-serif; }
Â  Â  .stButton>button { border-radius: 20px; border: 1px solid #00ccff; color: #00ccff; background: transparent; }
Â  Â  .stButton>button:hover { background: #00ccff; color: #000; border: 1px solid #00ccff; }
</style>
""", unsafe_allow_html=True)

st.title("ğŸŒŒ SDRIS Theory: Interactive Verification v2.0")
st.markdown("""
**Static-Dynamic Recursive Information Space**
Dieses Dashboard visualisiert die vier SÃ¤ulen der Theorie. Optimierte Berechnungskerne und interaktive Graphen.
""")

# --- HELPER: PLOTLY CHARTS ---
def plot_line_chart(x, y, title, xlabel, ylabel, color='#00ccff', trend_y=None):
Â  Â  fig = go.Figure()
Â  Â  fig.add_trace(go.Scatter(x=x, y=y, mode='lines', name='Signal', line=dict(color=color, width=2)))
Â  Â Â 
Â  Â  if trend_y is not None:
Â  Â  Â  Â  fig.add_trace(go.Scatter(x=x, y=trend_y, mode='lines', name='Trend', line=dict(color='white', width=1, dash='dash')))

Â  Â  fig.update_layout(
Â  Â  Â  Â  title=title,
Â  Â  Â  Â  xaxis_title=xlabel,
Â  Â  Â  Â  yaxis_title=ylabel,
Â  Â  Â  Â  template="plotly_dark",
Â  Â  Â  Â  margin=dict(l=20, r=20, t=40, b=20),
Â  Â  Â  Â  height=400,
Â  Â  Â  Â  hovermode="x unified"
Â  Â  )
Â  Â  return fig

# --- RECHENKERNE (Optimiert) ---

@st.cache_data
def simulate_universe_structure(steps, p_fork, p_link):
Â  Â  """Generiert das Raum-Zeit-Netzwerk."""
Â  Â  G = nx.Graph()
Â  Â  root = "0"
Â  Â  G.add_node(root, layer=0)
Â  Â  active_nodes = [root]
Â  Â Â 
Â  Â  for t in range(steps):
Â  Â  Â  Â  new_nodes = []
Â  Â  Â  Â  for node in active_nodes:
Â  Â  Â  Â  Â  Â  if random.random() < p_fork:
Â  Â  Â  Â  Â  Â  Â  Â  for i in range(2):Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  child = f"{node}.{i}"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  G.add_node(child, layer=t+1)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  G.add_edge(node, child, type='time')
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  new_nodes.append(child)
Â  Â  Â  Â Â 
Â  Â  Â  Â  if len(new_nodes) > 0:
Â  Â  Â  Â  Â  Â  # Optimierung: Sampling nur wenn nÃ¶tig
Â  Â  Â  Â  Â  Â  potential = new_nodes if len(new_nodes) < 50 else random.sample(new_nodes, 50)
Â  Â  Â  Â  Â  Â  for n1 in new_nodes:
Â  Â  Â  Â  Â  Â  Â  Â  for n2 in potential:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if n1 == n2: continue
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if random.random() < p_link:Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  G.add_edge(n1, n2, type='space')
Â  Â  Â  Â Â 
Â  Â  Â  Â  if new_nodes: active_nodes = new_nodes
Â  Â  return G

@st.cache_data
def get_saturation_data(max_dim_view):
Â  Â  """Simulation der dimensionalen SÃ¤ttigung."""
Â  Â  dims = []
Â  Â  lambdas = []
Â  Â  limit = max(21, max_dim_view)
Â  Â Â 
Â  Â  for d in range(3, limit + 1):
Â  Â  Â  Â  # Construct Tilt Matrix (Optimized construction)
Â  Â  Â  Â  # J ist schiefhermitesch
Â  Â  Â  Â  idx = np.arange(d - 1)
Â  Â  Â  Â  # Wir brauchen nur die Eigenwerte, keine volle Matrix fÃ¼r Plot
Â  Â  Â  Â  # Dies simuliert die Matrixstruktur:
Â  Â  Â  Â  # H = diag(i, 1) + diag(-i, -1)
Â  Â  Â  Â  # Eigenwerte fÃ¼r solche Toeplitz-Matrizen nÃ¤hern sich 2*cos(...) an
Â  Â  Â  Â Â 
Â  Â  Â  Â  # Exakte Berechnung via numpy
Â  Â  Â  Â  mat = np.zeros((d, d), dtype=complex)
Â  Â  Â  Â  mat[idx, idx + 1] = 1j
Â  Â  Â  Â  mat[idx + 1, idx] = -1j
Â  Â  Â  Â Â 
Â  Â  Â  Â  # Eigenvalues return complex, take max abs
Â  Â  Â  Â  # linalg.eigvals ist schneller als eig
Â  Â  Â  Â  lambdas.append(np.max(np.abs(np.linalg.eigvals(mat))))
Â  Â  Â  Â  dims.append(d)
Â  Â  Â  Â Â 
Â  Â  return dims, lambdas

@st.cache_data
def get_spectral_properties(n_dim):
Â  Â  """Check Stability."""
Â  Â  J = np.zeros((n_dim, n_dim), dtype=complex)
Â  Â  idx = np.arange(n_dim - 1)
Â  Â  J[idx, idx+1] = -1j
Â  Â  J[idx+1, idx] = 1j
Â  Â Â 
Â  Â  evals = np.linalg.eigvals(J)
Â  Â  sorted_evals = np.sort(np.abs(evals))
Â  Â  max_tension = np.max(sorted_evals)
Â  Â  has_zero_mode = np.any(np.isclose(sorted_evals, 0.0, atol=1e-5))
Â  Â Â 
Â  Â  return sorted_evals, max_tension, has_zero_mode

@st.cache_data
def simulate_flux_tunnel_dynamics(n_dim, damping_type, base_rate, steps=40):
Â  Â  """Entropic Dynamics."""
Â  Â  # Setup Matrix J
Â  Â  J = np.zeros((n_dim, n_dim), dtype=complex)
Â  Â  idx = np.arange(n_dim - 1)
Â  Â  J[idx, idx+1] = -1j
Â  Â  J[idx+1, idx] = 1j
Â  Â Â 
Â  Â  evals, evecs = np.linalg.eigh(J)
Â  Â Â 
Â  Â  # Init Random State
Â  Â  np.random.seed(42)
Â  Â  psi = np.random.rand(n_dim) + 1j * np.random.rand(n_dim)
Â  Â  psi = psi / np.linalg.norm(psi)
Â  Â Â 
Â  Â  t_vals = []
Â  Â  norms = []
Â  Â  dt = 0.1
Â  Â Â 
Â  Â  # Unitary Propagator
Â  Â  U = expm(-1j * J * dt)
Â  Â  current_psi = psi.copy()
Â  Â Â 
Â  Â  for t in range(steps + 1):
Â  Â  Â  Â  norm = np.linalg.norm(current_psi)
Â  Â  Â  Â  norms.append(norm)
Â  Â  Â  Â  t_vals.append(t * dt)
Â  Â  Â  Â Â 
Â  Â  Â  Â  # A. Unitary Step
Â  Â  Â  Â  current_psi = U @ current_psi
Â  Â  Â  Â Â 
Â  Â  Â  Â  # B. Damping Step
Â  Â  Â  Â  if damping_type == 'Constant':
Â  Â  Â  Â  Â  Â  decay = np.exp(-base_rate * dt)
Â  Â  Â  Â  Â  Â  current_psi = current_psi * decay
Â  Â  Â  Â  elif damping_type == 'Eigen-Dependent':
Â  Â  Â  Â  Â  Â  # Project -> Decay -> Reconstruct
Â  Â  Â  Â  Â  Â  coeffs = evecs.conj().T @ current_psi
Â  Â  Â  Â  Â  Â  decay_factors = np.exp(-base_rate * np.abs(evals) * dt)
Â  Â  Â  Â  Â  Â  coeffs = coeffs * decay_factors
Â  Â  Â  Â  Â  Â  current_psi = evecs @ coeffs
Â  Â  Â  Â  Â  Â Â 
Â  Â  return t_vals, norms

@st.cache_data
def get_vacuum_spectrum_optimized(num_primes, f_max):
Â  Â  """Vektorisierte Berechnung (High Performance)."""
Â  Â  # 1. Primzahlen generieren (Sieb des Eratosthenes)
Â  Â  limit = int(num_primes * 15) # SchÃ¤tzung fÃ¼r Obergrenze
Â  Â  is_prime = np.ones(limit, dtype=bool)
Â  Â  is_prime[:2] = False
Â  Â  for i in range(2, int(limit**0.5) + 1):
Â  Â  Â  Â  if is_prime[i]:
Â  Â  Â  Â  Â  Â  is_prime[i*i:limit:i] = False
Â  Â Â 
Â  Â  primes = np.nonzero(is_prime)[0][:num_primes]
Â  Â Â 
Â  Â  # 2. Vektorisierte Guinand-Weil Summe
Â  Â  # Wir nutzen Broadcasting: Frequencies (N, 1) x Primes (1, M)
Â  Â  freqs = np.linspace(0.1, f_max, 1000)
Â  Â Â 
Â  Â  # P_array shape: (1, num_primes)
Â  Â  p_arr = primes.reshape(1, -1)
Â  Â  # F_array shape: (num_freqs, 1)
Â  Â  f_arr = freqs.reshape(-1, 1)
Â  Â Â 
Â  Â  # Vorberechnungen
Â  Â  log_p = np.log(p_arr)
Â  Â  inv_sqrt_p = 1.0 / np.sqrt(p_arr)
Â  Â Â 
Â  Â  # Der Term: sum( (log p / sqrt p) * cos(2*pi*f*log p) )
Â  Â  # Argument fÃ¼r Cosinus:
Â  Â  args = 2 * np.pi * f_arr * log_p
Â  Â  cos_terms = np.cos(args)
Â  Â Â 
Â  Â  # Gewichtung
Â  Â  weighted_cos = cos_terms * (log_p * inv_sqrt_p)
Â  Â Â 
Â  Â  # Summe Ã¼ber alle Primzahlen (Achse 1)
Â  Â  amplitudes = np.sum(weighted_cos, axis=1)
Â  Â Â 
Â  Â  # PSD Berechnung
Â  Â  psd = (1/freqs) * (amplitudes**2)
Â  Â Â 
Â  Â  return freqs, psd

# --- SIDEBAR ---
st.sidebar.header("ğŸ›ï¸ SDRIS Control Center")

with st.sidebar.expander("1. Geometrie Parameter", expanded=True):
Â  Â  p_fork = st.slider("Zeit-Expansion (Fork)", 0.5, 1.0, 0.90)
Â  Â  p_link = st.slider("Raum-Dichte (Link)", 0.01, 0.5, 0.15)
Â  Â  steps_geo = st.slider("Simulation Steps", 5, 9, 7)

with st.sidebar.expander("2. SÃ¤ttigung & Entropie"):
Â  Â  max_dim_view = st.slider("Max Dimension View", 21, 100, 40)
Â  Â  sim_dim = st.selectbox("Flux Tunnel GrÃ¶ÃŸe", [5, 7, 13, 17, 19, 21, 31], index=1)
Â  Â  base_rate_input = st.slider("DÃ¤mpfungs-Rate", 0.01, 0.5, 0.08)

with st.sidebar.expander("3. Holographie (High Res)"):
Â  Â  num_primes = st.slider("Primzahl Tiefe", 100, 5000, 1000)
Â  Â  freq_max = st.slider("Frequenzbereich", 10, 200, 60)

# --- MAIN TABS ---
tab1, tab2, tab3, tab4 = st.tabs(["1. Geometrie", "2. SÃ¤ttigung", "3. Entropie", "4. Holometer"])

# TAB 1: GEOMETRIE
with tab1:
Â  Â  st.header("Emergent Geometry (Axiom I)")
Â  Â Â 
Â  Â  # Session State Logic to prevent redraw loop
Â  Â  if 'graph_data' not in st.session_state:
Â  Â  Â  Â  st.session_state.graph_data = None

Â  Â  col_btn, col_info = st.columns([1, 4])
Â  Â  with col_btn:
Â  Â  Â  Â  if st.button("ğŸ”„ Generieren", use_container_width=True) or st.session_state.graph_data is None:
Â  Â  Â  Â  Â  Â  st.session_state.graph_data = simulate_universe_structure(steps_geo, p_fork, p_link)
Â  Â Â 
Â  Â  G = st.session_state.graph_data
Â  Â Â 
Â  Â  with col_info:
Â  Â  Â  Â  st.caption(f"Knoten: {G.number_of_nodes()} | Kanten: {G.number_of_edges()}")

Â  Â  # Visualisierung
Â  Â  # Matplotlib ist hier immer noch besser fÃ¼r reine Netzwerke ohne WebGL-Overhead
Â  Â  fig, ax = plt.subplots(figsize=(10, 5))
Â  Â  pos = nx.spring_layout(G, seed=42, iterations=35) # Iterations reduziert fÃ¼r Speed
Â  Â Â 
Â  Â  # Color by Layer
Â  Â  colors = [G.nodes[n]['layer'] for n in G.nodes()]
Â  Â Â 
Â  Â  nx.draw_networkx_nodes(G, pos, node_size=60, node_color=colors, cmap=plt.cm.cool, ax=ax)
Â  Â  nx.draw_networkx_edges(G, pos, alpha=0.2, edge_color='#aaaaaa', ax=ax)
Â  Â  ax.axis('off')
Â  Â  fig.patch.set_facecolor('#0E1117')
Â  Â  st.pyplot(fig)

# ... (nach dem ersten Plot in Tab 2) ...
Â  Â  st.markdown("---")
Â  Â  st.subheader("ğŸ”¬ RÃ¶ntgenblick: Alle Eigenwerte pro Dimension")
Â  Â Â 
Â  Â  # Wir sammeln ALLE Eigenwerte fÃ¼r eine Heatmap
Â  Â  all_evals_data = []
Â  Â  for n in range(2, scan_range + 1):
Â  Â  Â  Â  J = np.zeros((n, n), dtype=complex)
Â  Â  Â  Â  idx = np.arange(n - 1)
Â  Â  Â  Â  J[idx, idx+1] = -1j
Â  Â  Â  Â  J[idx+1, idx] = 1j
Â  Â  Â  Â  evals = np.sort(np.abs(np.linalg.eigvals(J)))
Â  Â  Â  Â Â 
Â  Â  Â  Â  # FÃ¼r jeden der N Eigenwerte einen Eintrag
Â  Â  Â  Â  for i, val in enumerate(evals):
Â  Â  Â  Â  Â  Â  all_evals_data.append({"Dimension_N": n, "Eigenwert_Index": i+1, "Magnitude": val})
Â  Â  Â  Â  Â  Â Â 
Â  Â  df_spectrum = pd.DataFrame(all_evals_data)
Â  Â Â 
Â  Â  fig_spec = go.Figure()
Â  Â Â 
Â  Â  # Scatter Plot: Jeder Punkt ist EIN Eigenwert
Â  Â  fig_spec.add_trace(go.Scatter(
Â  Â  Â  Â  x=df_spectrum['Dimension_N'],
Â  Â  Â  Â  y=df_spectrum['Magnitude'],
Â  Â  Â  Â  mode='markers',
Â  Â  Â  Â  marker=dict(
Â  Â  Â  Â  Â  Â  size=6,
Â  Â  Â  Â  Â  Â  color=df_spectrum['Magnitude'], # Farbe zeigt Spannung
Â  Â  Â  Â  Â  Â  colorscale='Viridis',
Â  Â  Â  Â  Â  Â  showscale=True
Â  Â  Â  Â  ),
Â  Â  Â  Â  text=df_spectrum['Eigenwert_Index'],
Â  Â  Â  Â  hovertemplate="Dim: %{x}<br>Val: %{y:.3f}<extra></extra>"
Â  Â  ))
Â  Â Â 
Â  Â  fig_spec.update_layout(
Â  Â  Â  Â  title="Das volle Spektrum: N Dimensionen erzeugen N Eigenwerte",
Â  Â  Â  Â  xaxis_title="Dimension des Raumes (N)",
Â  Â  Â  Â  yaxis_title="Eigenwert Magnitude |Î»|",
Â  Â  Â  Â  template="plotly_dark",
Â  Â  Â  Â  height=500
Â  Â  )
Â  Â  st.plotly_chart(fig_spec, use_container_width=True)

# TAB 2: SÃ„TTIGUNG
# TAB 2: SÃ„TTIGUNG (ERWEITERT: Why 3D?)
with tab2:
Â  Â  st.header("Regime Stability & Dimensional Selection")
Â  Â Â 
Â  Â  # EinfÃ¼hrung
Â  Â  st.markdown("""
Â  Â  Warum hat unser Universum **3 Raumdimensionen**?Â 
Â  Â  Dieses Modul testet die "Ontologische StabilitÃ¤t" verschiedener Dimensionen N.
Â  Â  Wir suchen nach einem "Goldilocks-Punkt": Genug KomplexitÃ¤t fÃ¼r Leben, aber wenig genug Spannung fÃ¼r StabilitÃ¤t.
Â  Â  """)

Â  Â  # 1. Analyse-Parameter
Â  Â  col_ctrl, col_kpi = st.columns([1, 3])
Â  Â  with col_ctrl:
Â  Â  Â  Â  # Wir starten bei 2, da Dimension 1 (ein Punkt) keine Verbindungen haben kann.
Â  Â  Â  Â  # Max auf 21 erhÃ¶ht. Standardwert auf 17 gesetzt zum Testen.
Â  Â  Â  Â  scan_range = st.slider("Scan-Bereich (Dimensionen)", 2, 21, 17) Â  Â  Â Â 
Â  Â  Â  Â  st.info("N=3 ist der vermutete StabilitÃ¤ts-Punkt.")
Â  Â Â 
Â  Â  # 2. Berechnung des Scans
Â  Â  results = []
Â  Â  for n in range(2, scan_range + 1):
Â  Â  Â  Â  # Matrix Konstruktion (Tilt / Hamilton)
Â  Â  Â  Â  J = np.zeros((n, n), dtype=complex)
Â  Â  Â  Â  idx = np.arange(n - 1)
Â  Â  Â  Â  J[idx, idx+1] = -1j
Â  Â  Â  Â  J[idx+1, idx] = 1j
Â  Â  Â  Â Â 
Â  Â  Â  Â  evals = np.linalg.eigvals(J)
Â  Â  Â  Â  # Sortiere BetrÃ¤ge
Â  Â  Â  Â  abs_evals = np.sort(np.abs(evals))
Â  Â  Â  Â Â 
Â  Â  Â  Â  max_tension = np.max(abs_evals)
Â  Â  Â  Â Â 
Â  Â  Â  Â  # Stability Metrics
Â  Â  Â  Â  # A. Zero Mode Risk: Gibt es Eigenwerte nahe 0? (Schlecht fÃ¼r StabilitÃ¤t in diesem Modell)
Â  Â  Â  Â  has_zero = np.any(np.isclose(abs_evals, 0.0, atol=1e-2))
Â  Â  Â  Â Â 
Â  Â  Â  Â  # B. Spectral Gap: Abstand zwischen dem kleinsten (non-zero) und grÃ¶ÃŸten Eigenwert
Â  Â  Â  Â  # Ein groÃŸer Gap bedeutet oft "rigide" Strukturen (gut).
Â  Â  Â  Â  non_zero_evals = abs_evals[abs_evals > 1e-2]
Â  Â  Â  Â  gap = 0
Â  Â  Â  Â  if len(non_zero_evals) > 0:
Â  Â  Â  Â  Â  Â  gap = np.max(non_zero_evals) - np.min(non_zero_evals)
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  # C. Complexity Cost: Wir bestrafen hohe Dimensionen exponentiell
Â  Â  Â  Â  # Dies simuliert den Energieaufwand, um N Dimensionen kohÃ¤rent zu halten.
Â  Â  Â  Â  # Hypothese: Cost ~ Tension * log(N)
Â  Â  Â  Â  stability_score = (1.0 / (max_tension * np.log(n))) * (2.0 if not has_zero else 0.5)
Â  Â  Â  Â Â 
Â  Â  Â  Â  results.append({
Â  Â  Â  Â  Â  Â  "N": n,
Â  Â  Â  Â  Â  Â  "Tension": max_tension,
Â  Â  Â  Â  Â  Â  "ZeroMode": "Ja" if has_zero else "Nein",
Â  Â  Â  Â  Â  Â  "Gap": gap,
Â  Â  Â  Â  Â  Â  "Score": stability_score
Â  Â  Â  Â  })
Â  Â Â 
Â  Â  df_res = pd.DataFrame(results)

Â  Â  # 3. Visualisierung: Der DimensionalitÃ¤ts-Filter
Â  Â  with col_kpi:
Â  Â  Â  Â  # Wir heben N=3 (oder N=4 fÃ¼r Raumzeit) hervor
Â  Â  Â  Â  colors = ['#555555'] * len(df_res)
Â  Â  Â  Â  # Index von N=3 finden (da Liste bei N=2 startet, ist N=3 an Index 1)
Â  Â  Â  Â  if len(colors) > 1:
Â  Â  Â  Â  Â  Â  colors[1] = '#00ccff' # N=3 (Raum)
Â  Â  Â  Â  if len(colors) > 2:
Â  Â  Â  Â  Â  Â  colors[2] = '#ff4b4b' # N=4 (Raumzeit)

Â  Â  Â  Â  fig_dim = go.Figure()
Â  Â  Â  Â Â 
Â  Â  Â  Â  # Balken fÃ¼r StabilitÃ¤ts-Score
Â  Â  Â  Â  fig_dim.add_trace(go.Bar(
Â  Â  Â  Â  Â  Â  x=df_res['N'],Â 
Â  Â  Â  Â  Â  Â  y=df_res['Score'],
Â  Â  Â  Â  Â  Â  marker_color=colors,
Â  Â  Â  Â  Â  Â  name='Stability Score',
Â  Â  Â  Â  Â  Â  text=df_res['ZeroMode'],
Â  Â  Â  Â  Â  Â  textposition='auto'
Â  Â  Â  Â  ))
Â  Â  Â  Â Â 
Â  Â  Â  Â  # Linie fÃ¼r Tension
Â  Â  Â  Â  fig_dim.add_trace(go.Scatter(
Â  Â  Â  Â  Â  Â  x=df_res['N'],
Â  Â  Â  Â  Â  Â  y=df_res['Tension'],
Â  Â  Â  Â  Â  Â  mode='lines+markers',
Â  Â  Â  Â  Â  Â  name='Ontological Tension',
Â  Â  Â  Â  Â  Â  line=dict(color='white', dash='dot'),
Â  Â  Â  Â  Â  Â  yaxis='y2'
Â  Â  Â  Â  ))

Â  Â  Â  Â  fig_dim.update_layout(
Â  Â  Â  Â  Â  Â  title="Warum 3D? Der StabilitÃ¤ts-Check",
Â  Â  Â  Â  Â  Â  xaxis_title="Dimension (N)",
Â  Â  Â  Â  Â  Â  yaxis_title="StabilitÃ¤ts-Score (hÃ¶her ist besser)",
Â  Â  Â  Â  Â  Â  yaxis2=dict(title="Tension (Stress)", overlaying='y', side='right'),
Â  Â  Â  Â  Â  Â  template="plotly_dark",
Â  Â  Â  Â  Â  Â  height=450,
Â  Â  Â  Â  Â  Â  barmode='group'
Â  Â  Â  Â  )
Â  Â  Â  Â  st.plotly_chart(fig_dim, use_container_width=True)

Â  Â  # 4. Interpretation
Â  Â  st.markdown("### ğŸ§¬ Analyse der Ergebnisse")
Â  Â  col1, col2 = st.columns(2)
Â  Â  with col1:
Â  Â  Â  Â  st.success("**Warum N=3 gewinnt:**")
Â  Â  Â  Â  st.markdown("""
Â  Â  Â  Â  * N=3 bietet den besten Kompromiss zwischen **Freiheitsgraden** (Bewegung mÃ¶glich) und **struktureller IntegritÃ¤t**.
Â  Â  Â  Â  * Ab N=4 steigt die "Tension" (weiÃŸe Linie) stark an, was das System energetisch teuer macht.
Â  Â  Â  Â  * In ungeraden Dimensionen (3, 5, 7) treten oft "Zero Modes" auf (siehe Text im Balken), die WurmlÃ¶cher/InstabilitÃ¤t begÃ¼nstigen kÃ¶nnen, aber N=3 ist klein genug, um dies zu kompensieren.
Â  Â  Â  Â  """)
Â  Â  with col2:
Â  Â  Â  Â  st.warning("**Das Problem hÃ¶herer Dimensionen:**")
Â  Â  Â  Â  st.markdown("""
Â  Â  Â  Â  * Physikalisch: In N>3 werden Gravitations-Orbits instabil ($F \propto 1/r^{N-1}$). Planeten stÃ¼rzen in ihre Sterne.
Â  Â  Â  Â  * SDRIS-Theorie: Die Informationsdichte wird zu hoch; das Netzwerk kollabiert zu einem Schwarzen Loch, um sich zu schÃ¼tzen.
Â  Â  Â  Â  """)

# TAB 3: ENTROPIE
with tab3:
Â  Â  st.header("Axiom IV: Entropic Damping Dynamics")
Â  Â Â 
Â  Â  t, norms_const = simulate_flux_tunnel_dynamics(sim_dim, 'Constant', base_rate_input)
Â  Â  _, norms_eigen = simulate_flux_tunnel_dynamics(sim_dim, 'Eigen-Dependent', base_rate_input)
Â  Â Â 
Â  Â  fig_ent = go.Figure()
Â  Â  fig_ent.add_trace(go.Scatter(x=t, y=norms_const, name='Constant Damping (Naive)', line=dict(dash='dot', color='gray')))
Â  Â  fig_ent.add_trace(go.Scatter(x=t, y=norms_eigen, name='Eigen-Dependent (Hawking)', line=dict(color='#ff4b4b', width=3)))
Â  Â Â 
Â  Â  fig_ent.update_layout(
Â  Â  Â  Â  title=f"Information Loss in Flux Tunnel (Dim={sim_dim})",
Â  Â  Â  Â  xaxis_title="Time (t)",
Â  Â  Â  Â  yaxis_title="Information Norm ||Ïˆ||",
Â  Â  Â  Â  template="plotly_dark",
Â  Â  Â  Â  height=450
Â  Â  )
Â  Â  st.plotly_chart(fig_ent, use_container_width=True)
Â  Â Â 
Â  Â  loss_eigen = (1 - norms_eigen[-1]) * 100
Â  Â  st.metric("Information Loss (t=end)", f"{loss_eigen:.2f}%", delta="-Entropy")

# TAB 4: HOLOMETER
import streamlit as st
import networkx as nx
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
from scipy.linalg import expm

# --- KONFIGURATION ---
st.set_page_config(
Â  Â  page_title="SDRIS Framework Simulation Pro",Â 
Â  Â  page_icon="ğŸŒŒ",
Â  Â  layout="wide"
)

# Custom CSS fÃ¼r professionelleren Look
st.markdown("""
<style>
Â  Â  .stApp { background-color: #0E1117; }
Â  Â  h1, h2, h3 { color: #00ccff !important; font-family: 'Helvetica Neue', sans-serif; }
Â  Â  .stButton>button { border-radius: 20px; border: 1px solid #00ccff; color: #00ccff; background: transparent; }
Â  Â  .stButton>button:hover { background: #00ccff; color: #000; border: 1px solid #00ccff; }
</style>
""", unsafe_allow_html=True)

st.title("ğŸŒŒ SDRIS Theory: Interactive Verification v2.0")
st.markdown("""
**Static-Dynamic Recursive Information Space**
Dieses Dashboard visualisiert die vier SÃ¤ulen der Theorie. Optimierte Berechnungskerne und interaktive Graphen.
""")

# --- HELPER: PLOTLY CHARTS ---
def plot_line_chart(x, y, title, xlabel, ylabel, color='#00ccff', trend_y=None):
Â  Â  fig = go.Figure()
Â  Â  fig.add_trace(go.Scatter(x=x, y=y, mode='lines', name='Signal', line=dict(color=color, width=2)))
Â  Â Â 
Â  Â  if trend_y is not None:
Â  Â  Â  Â  fig.add_trace(go.Scatter(x=x, y=trend_y, mode='lines', name='Trend', line=dict(color='white', width=1, dash='dash')))

Â  Â  fig.update_layout(
Â  Â  Â  Â  title=title,
Â  Â  Â  Â  xaxis_title=xlabel,
Â  Â  Â  Â  yaxis_title=ylabel,
Â  Â  Â  Â  template="plotly_dark",
Â  Â  Â  Â  margin=dict(l=20, r=20, t=40, b=20),
Â  Â  Â  Â  height=400,
Â  Â  Â  Â  hovermode="x unified"
Â  Â  )
Â  Â  return fig

# --- RECHENKERNE (Optimiert) ---

@st.cache_data
def simulate_universe_structure(steps, p_fork, p_link):
Â  Â  """Generiert das Raum-Zeit-Netzwerk."""
Â  Â  G = nx.Graph()
Â  Â  root = "0"
Â  Â  G.add_node(root, layer=0)
Â  Â  active_nodes = [root]
Â  Â Â 
Â  Â  for t in range(steps):
Â  Â  Â  Â  new_nodes = []
Â  Â  Â  Â  for node in active_nodes:
Â  Â  Â  Â  Â  Â  if random.random() < p_fork:
Â  Â  Â  Â  Â  Â  Â  Â  for i in range(2):Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  child = f"{node}.{i}"
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  G.add_node(child, layer=t+1)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  G.add_edge(node, child, type='time')
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  new_nodes.append(child)
Â  Â  Â  Â Â 
Â  Â  Â  Â  if len(new_nodes) > 0:
Â  Â  Â  Â  Â  Â  # Optimierung: Sampling nur wenn nÃ¶tig
Â  Â  Â  Â  Â  Â  potential = new_nodes if len(new_nodes) < 50 else random.sample(new_nodes, 50)
Â  Â  Â  Â  Â  Â  for n1 in new_nodes:
Â  Â  Â  Â  Â  Â  Â  Â  for n2 in potential:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if n1 == n2: continue
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if random.random() < p_link:Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  G.add_edge(n1, n2, type='space')
Â  Â  Â  Â Â 
Â  Â  Â  Â  if new_nodes: active_nodes = new_nodes
Â  Â  return G

@st.cache_data
def get_saturation_data(max_dim_view):
Â  Â  """Simulation der dimensionalen SÃ¤ttigung."""
Â  Â  dims = []
Â  Â  lambdas = []
Â  Â  limit = max(21, max_dim_view)
Â  Â Â 
Â  Â  for d in range(3, limit + 1):
Â  Â  Â  Â  # Construct Tilt Matrix (Optimized construction)
Â  Â  Â  Â  # J ist schiefhermitesch
Â  Â  Â  Â  idx = np.arange(d - 1)
Â  Â  Â  Â  # Wir brauchen nur die Eigenwerte, keine volle Matrix fÃ¼r Plot
Â  Â  Â  Â  # Dies simuliert die Matrixstruktur:
Â  Â  Â  Â  # H = diag(i, 1) + diag(-i, -1)
Â  Â  Â  Â  # Eigenwerte fÃ¼r solche Toeplitz-Matrizen nÃ¤hern sich 2*cos(...) an
Â  Â  Â  Â Â 
Â  Â  Â  Â  # Exakte Berechnung via numpy
Â  Â  Â  Â  mat = np.zeros((d, d), dtype=complex)
Â  Â  Â  Â  mat[idx, idx + 1] = 1j
Â  Â  Â  Â  mat[idx + 1, idx] = -1j
Â  Â  Â  Â Â 
Â  Â  Â  Â  # Eigenvalues return complex, take max abs
Â  Â  Â  Â  # linalg.eigvals ist schneller als eig
Â  Â  Â  Â  lambdas.append(np.max(np.abs(np.linalg.eigvals(mat))))
Â  Â  Â  Â  dims.append(d)
Â  Â  Â  Â Â 
Â  Â  return dims, lambdas

@st.cache_data
def get_spectral_properties(n_dim):
Â  Â  """Check Stability."""
Â  Â  J = np.zeros((n_dim, n_dim), dtype=complex)
Â  Â  idx = np.arange(n_dim - 1)
Â  Â  J[idx, idx+1] = -1j
Â  Â  J[idx+1, idx] = 1j
Â  Â Â 
Â  Â  evals = np.linalg.eigvals(J)
Â  Â  sorted_evals = np.sort(np.abs(evals))
Â  Â  max_tension = np.max(sorted_evals)
Â  Â  has_zero_mode = np.any(np.isclose(sorted_evals, 0.0, atol=1e-5))
Â  Â Â 
Â  Â  return sorted_evals, max_tension, has_zero_mode

@st.cache_data
def simulate_flux_tunnel_dynamics(n_dim, damping_type, base_rate, steps=40):
Â  Â  """Entropic Dynamics."""
Â  Â  # Setup Matrix J
Â  Â  J = np.zeros((n_dim, n_dim), dtype=complex)
Â  Â  idx = np.arange(n_dim - 1)
Â  Â  J[idx, idx+1] = -1j
Â  Â  J[idx+1, idx] = 1j
Â  Â Â 
Â  Â  evals, evecs = np.linalg.eigh(J)
Â  Â Â 
Â  Â  # Init Random State
Â  Â  np.random.seed(42)
Â  Â  psi = np.random.rand(n_dim) + 1j * np.random.rand(n_dim)
Â  Â  psi = psi / np.linalg.norm(psi)
Â  Â Â 
Â  Â  t_vals = []
Â  Â  norms = []
Â  Â  dt = 0.1
Â  Â Â 
Â  Â  # Unitary Propagator
Â  Â  U = expm(-1j * J * dt)
Â  Â  current_psi = psi.copy()
Â  Â Â 
Â  Â  for t in range(steps + 1):
Â  Â  Â  Â  norm = np.linalg.norm(current_psi)
Â  Â  Â  Â  norms.append(norm)
Â  Â  Â  Â  t_vals.append(t * dt)
Â  Â  Â  Â Â 
Â  Â  Â  Â  # A. Unitary Step
Â  Â  Â  Â  current_psi = U @ current_psi
Â  Â  Â  Â Â 
Â  Â  Â  Â  # B. Damping Step
Â  Â  Â  Â  if damping_type == 'Constant':
Â  Â  Â  Â  Â  Â  decay = np.exp(-base_rate * dt)
Â  Â  Â  Â  Â  Â  current_psi = current_psi * decay
Â  Â  Â  Â  elif damping_type == 'Eigen-Dependent':
Â  Â  Â  Â  Â  Â  # Project -> Decay -> Reconstruct
Â  Â  Â  Â  Â  Â  coeffs = evecs.conj().T @ current_psi
Â  Â  Â  Â  Â  Â  decay_factors = np.exp(-base_rate * np.abs(evals) * dt)
Â  Â  Â  Â  Â  Â  coeffs = coeffs * decay_factors
Â  Â  Â  Â  Â  Â  current_psi = evecs @ coeffs
Â  Â  Â  Â  Â  Â Â 
Â  Â  return t_vals, norms

@st.cache_data
def get_vacuum_spectrum_optimized(num_primes, f_max):
Â  Â  """Vektorisierte Berechnung (High Performance)."""
Â  Â  # 1. Primzahlen generieren (Sieb des Eratosthenes)
Â  Â  limit = int(num_primes * 15) # SchÃ¤tzung fÃ¼r Obergrenze
Â  Â  is_prime = np.ones(limit, dtype=bool)
Â  Â  is_prime[:2] = False
Â  Â  for i in range(2, int(limit**0.5) + 1):
Â  Â  Â  Â  if is_prime[i]:
Â  Â  Â  Â  Â  Â  is_prime[i*i:limit:i] = False
Â  Â Â 
Â  Â  primes = np.nonzero(is_prime)[0][:num_primes]
Â  Â Â 
Â  Â  # 2. Vektorisierte Guinand-Weil Summe
Â  Â  # Wir nutzen Broadcasting: Frequencies (N, 1) x Primes (1, M)
Â  Â  freqs = np.linspace(0.1, f_max, 1000)
Â  Â Â 
Â  Â  # P_array shape: (1, num_primes)
Â  Â  p_arr = primes.reshape(1, -1)
Â  Â  # F_array shape: (num_freqs, 1)
Â  Â  f_arr = freqs.reshape(-1, 1)
Â  Â Â 
Â  Â  # Vorberechnungen
Â  Â  log_p = np.log(p_arr)
Â  Â  inv_sqrt_p = 1.0 / np.sqrt(p_arr)
Â  Â Â 
Â  Â  # Der Term: sum( (log p / sqrt p) * cos(2*pi*f*log p) )
Â  Â  # Argument fÃ¼r Cosinus:
Â  Â  args = 2 * np.pi * f_arr * log_p
Â  Â  cos_terms = np.cos(args)
Â  Â Â 
Â  Â  # Gewichtung
Â  Â  weighted_cos = cos_terms * (log_p * inv_sqrt_p)
Â  Â Â 
Â  Â  # Summe Ã¼ber alle Primzahlen (Achse 1)
Â  Â  amplitudes = np.sum(weighted_cos, axis=1)
Â  Â Â 
Â  Â  # PSD Berechnung
Â  Â  psd = (1/freqs) * (amplitudes**2)
Â  Â Â 
Â  Â  return freqs, psd

# --- SIDEBAR ---
st.sidebar.header("ğŸ›ï¸ SDRIS Control Center")

with st.sidebar.expander("1. Geometrie Parameter", expanded=True):
Â  Â  p_fork = st.slider("Zeit-Expansion (Fork)", 0.5, 1.0, 0.90)
Â  Â  p_link = st.slider("Raum-Dichte (Link)", 0.01, 0.5, 0.15)
Â  Â  steps_geo = st.slider("Simulation Steps", 5, 9, 7)

with st.sidebar.expander("2. SÃ¤ttigung & Entropie"):
Â  Â  max_dim_view = st.slider("Max Dimension View", 21, 100, 40)
Â  Â  sim_dim = st.selectbox("Flux Tunnel GrÃ¶ÃŸe", [5, 7, 13, 17, 19, 21, 31], index=1)
Â  Â  base_rate_input = st.slider("DÃ¤mpfungs-Rate", 0.01, 0.5, 0.08)

with st.sidebar.expander("3. Holographie (High Res)"):
Â  Â  num_primes = st.slider("Primzahl Tiefe", 100, 5000, 1000)
Â  Â  freq_max = st.slider("Frequenzbereich", 10, 200, 60)

# --- MAIN TABS ---
tab1, tab2, tab3, tab4 = st.tabs(["1. Geometrie", "2. SÃ¤ttigung", "3. Entropie", "4. Holometer"])

# TAB 1: GEOMETRIE
with tab1:
Â  Â  st.header("Emergent Geometry (Axiom I)")
Â  Â Â 
Â  Â  # Session State Logic to prevent redraw loop
Â  Â  if 'graph_data' not in st.session_state:
Â  Â  Â  Â  st.session_state.graph_data = None

Â  Â  col_btn, col_info = st.columns([1, 4])
Â  Â  with col_btn:
Â  Â  Â  Â  if st.button("ğŸ”„ Generieren", use_container_width=True) or st.session_state.graph_data is None:
Â  Â  Â  Â  Â  Â  st.session_state.graph_data = simulate_universe_structure(steps_geo, p_fork, p_link)
Â  Â Â 
Â  Â  G = st.session_state.graph_data
Â  Â Â 
Â  Â  with col_info:
Â  Â  Â  Â  st.caption(f"Knoten: {G.number_of_nodes()} | Kanten: {G.number_of_edges()}")

Â  Â  # Visualisierung
Â  Â  # Matplotlib ist hier immer noch besser fÃ¼r reine Netzwerke ohne WebGL-Overhead
Â  Â  fig, ax = plt.subplots(figsize=(10, 5))
Â  Â  pos = nx.spring_layout(G, seed=42, iterations=35) # Iterations reduziert fÃ¼r Speed
Â  Â Â 
Â  Â  # Color by Layer
Â  Â  colors = [G.nodes[n]['layer'] for n in G.nodes()]
Â  Â Â 
Â  Â  nx.draw_networkx_nodes(G, pos, node_size=60, node_color=colors, cmap=plt.cm.cool, ax=ax)
Â  Â  nx.draw_networkx_edges(G, pos, alpha=0.2, edge_color='#aaaaaa', ax=ax)
Â  Â  ax.axis('off')
Â  Â  fig.patch.set_facecolor('#0E1117')
Â  Â  st.pyplot(fig)

# ... (nach dem ersten Plot in Tab 2) ...
Â  Â  st.markdown("---")
Â  Â  st.subheader("ğŸ”¬ RÃ¶ntgenblick: Alle Eigenwerte pro Dimension")
Â  Â Â 
Â  Â  # Wir sammeln ALLE Eigenwerte fÃ¼r eine Heatmap
Â  Â  all_evals_data = []
Â  Â  for n in range(2, scan_range + 1):
Â  Â  Â  Â  J = np.zeros((n, n), dtype=complex)
Â  Â  Â  Â  idx = np.arange(n - 1)
Â  Â  Â  Â  J[idx, idx+1] = -1j
Â  Â  Â  Â  J[idx+1, idx] = 1j
Â  Â  Â  Â  evals = np.sort(np.abs(np.linalg.eigvals(J)))
Â  Â  Â  Â Â 
Â  Â  Â  Â  # FÃ¼r jeden der N Eigenwerte einen Eintrag
Â  Â  Â  Â  for i, val in enumerate(evals):
Â  Â  Â  Â  Â  Â  all_evals_data.append({"Dimension_N": n, "Eigenwert_Index": i+1, "Magnitude": val})
Â  Â  Â  Â  Â  Â Â 
Â  Â  df_spectrum = pd.DataFrame(all_evals_data)
Â  Â Â 
Â  Â  fig_spec = go.Figure()
Â  Â Â 
Â  Â  # Scatter Plot: Jeder Punkt ist EIN Eigenwert
Â  Â  fig_spec.add_trace(go.Scatter(
Â  Â  Â  Â  x=df_spectrum['Dimension_N'],
Â  Â  Â  Â  y=df_spectrum['Magnitude'],
Â  Â  Â  Â  mode='markers',
Â  Â  Â  Â  marker=dict(
Â  Â  Â  Â  Â  Â  size=6,
Â  Â  Â  Â  Â  Â  color=df_spectrum['Magnitude'], # Farbe zeigt Spannung
Â  Â  Â  Â  Â  Â  colorscale='Viridis',
Â  Â  Â  Â  Â  Â  showscale=True
Â  Â  Â  Â  ),
Â  Â  Â  Â  text=df_spectrum['Eigenwert_Index'],
Â  Â  Â  Â  hovertemplate="Dim: %{x}<br>Val: %{y:.3f}<extra></extra>"
Â  Â  ))
Â  Â Â 
Â  Â  fig_spec.update_layout(
Â  Â  Â  Â  title="Das volle Spektrum: N Dimensionen erzeugen N Eigenwerte",
Â  Â  Â  Â  xaxis_title="Dimension des Raumes (N)",
Â  Â  Â  Â  yaxis_title="Eigenwert Magnitude |Î»|",
Â  Â  Â  Â  template="plotly_dark",
Â  Â  Â  Â  height=500
Â  Â  )
Â  Â  st.plotly_chart(fig_spec, use_container_width=True)

# TAB 2: SÃ„TTIGUNG
# TAB 2: SÃ„TTIGUNG (ERWEITERT: Why 3D?)
with tab2:
Â  Â  st.header("Regime Stability & Dimensional Selection")
Â  Â Â 
Â  Â  # EinfÃ¼hrung
Â  Â  st.markdown("""
Â  Â  Warum hat unser Universum **3 Raumdimensionen**?Â 
Â  Â  Dieses Modul testet die "Ontologische StabilitÃ¤t" verschiedener Dimensionen N.
Â  Â  Wir suchen nach einem "Goldilocks-Punkt": Genug KomplexitÃ¤t fÃ¼r Leben, aber wenig genug Spannung fÃ¼r StabilitÃ¤t.
Â  Â  """)

Â  Â  # 1. Analyse-Parameter
Â  Â  col_ctrl, col_kpi = st.columns([1, 3])
Â  Â  with col_ctrl:
Â  Â  Â  Â  # Wir starten bei 2, da Dimension 1 (ein Punkt) keine Verbindungen haben kann.
Â  Â  Â  Â  # Max auf 21 erhÃ¶ht. Standardwert auf 17 gesetzt zum Testen.
Â  Â  Â  Â  scan_range = st.slider("Scan-Bereich (Dimensionen)", 2, 21, 17) Â  Â  Â Â 
Â  Â  Â  Â  st.info("N=3 ist der vermutete StabilitÃ¤ts-Punkt.")
Â  Â Â 
Â  Â  # 2. Berechnung des Scans
Â  Â  results = []
Â  Â  for n in range(2, scan_range + 1):
Â  Â  Â  Â  # Matrix Konstruktion (Tilt / Hamilton)
Â  Â  Â  Â  J = np.zeros((n, n), dtype=complex)
Â  Â  Â  Â  idx = np.arange(n - 1)
Â  Â  Â  Â  J[idx, idx+1] = -1j
Â  Â  Â  Â  J[idx+1, idx] = 1j
Â  Â  Â  Â Â 
Â  Â  Â  Â  evals = np.linalg.eigvals(J)
Â  Â  Â  Â  # Sortiere BetrÃ¤ge
Â  Â  Â  Â  abs_evals = np.sort(np.abs(evals))
Â  Â  Â  Â Â 
Â  Â  Â  Â  max_tension = np.max(abs_evals)
Â  Â  Â  Â Â 
Â  Â  Â  Â  # Stability Metrics
Â  Â  Â  Â  # A. Zero Mode Risk: Gibt es Eigenwerte nahe 0? (Schlecht fÃ¼r StabilitÃ¤t in diesem Modell)
Â  Â  Â  Â  has_zero = np.any(np.isclose(abs_evals, 0.0, atol=1e-2))
Â  Â  Â  Â Â 
Â  Â  Â  Â  # B. Spectral Gap: Abstand zwischen dem kleinsten (non-zero) und grÃ¶ÃŸten Eigenwert
Â  Â  Â  Â  # Ein groÃŸer Gap bedeutet oft "rigide" Strukturen (gut).
Â  Â  Â  Â  non_zero_evals = abs_evals[abs_evals > 1e-2]
Â  Â  Â  Â  gap = 0
Â  Â  Â  Â  if len(non_zero_evals) > 0:
Â  Â  Â  Â  Â  Â  gap = np.max(non_zero_evals) - np.min(non_zero_evals)
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  # C. Complexity Cost: Wir bestrafen hohe Dimensionen exponentiell
Â  Â  Â  Â  # Dies simuliert den Energieaufwand, um N Dimensionen kohÃ¤rent zu halten.
Â  Â  Â  Â  # Hypothese: Cost ~ Tension * log(N)
Â  Â  Â  Â  stability_score = (1.0 / (max_tension * np.log(n))) * (2.0 if not has_zero else 0.5)
Â  Â  Â  Â Â 
Â  Â  Â  Â  results.append({
Â  Â  Â  Â  Â  Â  "N": n,
Â  Â  Â  Â  Â  Â  "Tension": max_tension,
Â  Â  Â  Â  Â  Â  "ZeroMode": "Ja" if has_zero else "Nein",
Â  Â  Â  Â  Â  Â  "Gap": gap,
Â  Â  Â  Â  Â  Â  "Score": stability_score
Â  Â  Â  Â  })
Â  Â Â 
Â  Â  df_res = pd.DataFrame(results)

Â  Â  # 3. Visualisierung: Der DimensionalitÃ¤ts-Filter
Â  Â  with col_kpi:
Â  Â  Â  Â  # Wir heben N=3 (oder N=4 fÃ¼r Raumzeit) hervor
Â  Â  Â  Â  colors = ['#555555'] * len(df_res)
Â  Â  Â  Â  # Index von N=3 finden (da Liste bei N=2 startet, ist N=3 an Index 1)
Â  Â  Â  Â  if len(colors) > 1:
Â  Â  Â  Â  Â  Â  colors[1] = '#00ccff' # N=3 (Raum)
Â  Â  Â  Â  if len(colors) > 2:
Â  Â  Â  Â  Â  Â  colors[2] = '#ff4b4b' # N=4 (Raumzeit)

Â  Â  Â  Â  fig_dim = go.Figure()
Â  Â  Â  Â Â 
Â  Â  Â  Â  # Balken fÃ¼r StabilitÃ¤ts-Score
Â  Â  Â  Â  fig_dim.add_trace(go.Bar(
Â  Â  Â  Â  Â  Â  x=df_res['N'],Â 
Â  Â  Â  Â  Â  Â  y=df_res['Score'],
Â  Â  Â  Â  Â  Â  marker_color=colors,
Â  Â  Â  Â  Â  Â  name='Stability Score',
Â  Â  Â  Â  Â  Â  text=df_res['ZeroMode'],
Â  Â  Â  Â  Â  Â  textposition='auto'
Â  Â  Â  Â  ))
Â  Â  Â  Â Â 
Â  Â  Â  Â  # Linie fÃ¼r Tension
Â  Â  Â  Â  fig_dim.add_trace(go.Scatter(
Â  Â  Â  Â  Â  Â  x=df_res['N'],
Â  Â  Â  Â  Â  Â  y=df_res['Tension'],
Â  Â  Â  Â  Â  Â  mode='lines+markers',
Â  Â  Â  Â  Â  Â  name='Ontological Tension',
Â  Â  Â  Â  Â  Â  line=dict(color='white', dash='dot'),
Â  Â  Â  Â  Â  Â  yaxis='y2'
Â  Â  Â  Â  ))

Â  Â  Â  Â  fig_dim.update_layout(
Â  Â  Â  Â  Â  Â  title="Warum 3D? Der StabilitÃ¤ts-Check",
Â  Â  Â  Â  Â  Â  xaxis_title="Dimension (N)",
Â  Â  Â  Â  Â  Â  yaxis_title="StabilitÃ¤ts-Score (hÃ¶her ist besser)",
Â  Â  Â  Â  Â  Â  yaxis2=dict(title="Tension (Stress)", overlaying='y', side='right'),
Â  Â  Â  Â  Â  Â  template="plotly_dark",
Â  Â  Â  Â  Â  Â  height=450,
Â  Â  Â  Â  Â  Â  barmode='group'
Â  Â  Â  Â  )
Â  Â  Â  Â  st.plotly_chart(fig_dim, use_container_width=True)

Â  Â  # 4. Interpretation
Â  Â  st.markdown("### ğŸ§¬ Analyse der Ergebnisse")
Â  Â  col1, col2 = st.columns(2)
Â  Â  with col1:
Â  Â  Â  Â  st.success("**Warum N=3 gewinnt:**")
Â  Â  Â  Â  st.markdown("""
Â  Â  Â  Â  * N=3 bietet den besten Kompromiss zwischen **Freiheitsgraden** (Bewegung mÃ¶glich) und **struktureller IntegritÃ¤t**.
Â  Â  Â  Â  * Ab N=4 steigt die "Tension" (weiÃŸe Linie) stark an, was das System energetisch teuer macht.
Â  Â  Â  Â  * In ungeraden Dimensionen (3, 5, 7) treten oft "Zero Modes" auf (siehe Text im Balken), die WurmlÃ¶cher/InstabilitÃ¤t begÃ¼nstigen kÃ¶nnen, aber N=3 ist klein genug, um dies zu kompensieren.
Â  Â  Â  Â  """)
Â  Â  with col2:
Â  Â  Â  Â  st.warning("**Das Problem hÃ¶herer Dimensionen:**")
Â  Â  Â  Â  st.markdown("""
Â  Â  Â  Â  * Physikalisch: In N>3 werden Gravitations-Orbits instabil ($F \propto 1/r^{N-1}$). Planeten stÃ¼rzen in ihre Sterne.
Â  Â  Â  Â  * SDRIS-Theorie: Die Informationsdichte wird zu hoch; das Netzwerk kollabiert zu einem Schwarzen Loch, um sich zu schÃ¼tzen.
Â  Â  Â  Â  """)

# TAB 3: ENTROPIE
with tab3:
Â  Â  st.header("Axiom IV: Entropic Damping Dynamics")
Â  Â Â 
Â  Â  t, norms_const = simulate_flux_tunnel_dynamics(sim_dim, 'Constant', base_rate_input)
Â  Â  _, norms_eigen = simulate_flux_tunnel_dynamics(sim_dim, 'Eigen-Dependent', base_rate_input)
Â  Â Â 
Â  Â  fig_ent = go.Figure()
Â  Â  fig_ent.add_trace(go.Scatter(x=t, y=norms_const, name='Constant Damping (Naive)', line=dict(dash='dot', color='gray')))
Â  Â  fig_ent.add_trace(go.Scatter(x=t, y=norms_eigen, name='Eigen-Dependent (Hawking)', line=dict(color='#ff4b4b', width=3)))
Â  Â Â 
Â  Â  fig_ent.update_layout(
Â  Â  Â  Â  title=f"Information Loss in Flux Tunnel (Dim={sim_dim})",
Â  Â  Â  Â  xaxis_title="Time (t)",
Â  Â  Â  Â  yaxis_title="Information Norm ||Ïˆ||",
Â  Â  Â  Â  template="plotly_dark",
Â  Â  Â  Â  height=450
Â  Â  )
Â  Â  st.plotly_chart(fig_ent, use_container_width=True)
Â  Â Â 
Â  Â  loss_eigen = (1 - norms_eigen[-1]) * 100
Â  Â  st.metric("Information Loss (t=end)", f"{loss_eigen:.2f}%", delta="-Entropy")

# TAB 4: HOLOMETER
with tab4:
Â  Â  st.header("Vacuum Holography (Riemann-Zeta Refined)")
Â  Â  st.markdown("Verwendet **vektorisierte Guinand-Weil-Transformation** fÃ¼r High-Performance Rausch-Synthese.")
Â  Â Â 
Â  Â  # Optimized Calculation
Â  Â  freqs, psd = get_vacuum_spectrum_optimized(num_primes, freq_max)
Â  Â Â 
Â  Â  # Log-Log Trend Calculation
Â  Â  valid_idx = np.where(psd > 1e-9)
Â  Â  z = np.polyfit(np.log(freqs[valid_idx]), np.log(psd[valid_idx]), 1)
Â  Â  p_func = np.poly1d(z)
Â  Â  trend_y = np.exp(p_func(np.log(freqs)))
Â  Â Â 
Â  Â  # Plotly Log-Log Chart
Â  Â  fig_holo = go.Figure()
Â  Â  fig_holo.add_trace(go.Scatter(x=freqs, y=psd, name='Quantum Noise', line=dict(color='#ffaa00', width=1), fill='tozeroy'))
Â  Â  fig_holo.add_trace(go.Scatter(x=freqs, y=trend_y, name=f'Fractal Trend (Î±={z[0]:.2f})', line=dict(color='white', width=1, dash='dash')))
Â  Â Â 
Â  Â  fig_holo.update_layout(
Â  Â  Â  Â  title="Spectral Density S(f) [Log-Log]",
Â  Â  Â  Â  xaxis_type="log",
Â  Â  Â  Â  yaxis_type="log",
Â  Â  Â  Â  xaxis_title="Frequenz (Hz)",
Â  Â  Â  Â  yaxis_title="Power Spectral Density",
Â  Â  Â  Â  template="plotly_dark",
Â  Â  Â  Â  height=500
Â  Â  )
Â  Â  st.plotly_chart(fig_holo, use_container_width=True)

Â  Â  # Export Logic
Â  Â  col1, col2 = st.columns(2)
Â  Â  with col1:
Â  Â  Â  Â  peak_idx = np.argmax(psd)
Â  Â  Â  Â  st.info(f"**Dominante Resonanz:** {freqs[peak_idx]:.4f} Hz")
Â  Â Â 
Â  Â  with col2:
Â  Â  Â  Â  export_df = pd.DataFrame({"Frequency": freqs, "PSD": psd})
Â  Â  Â  Â  st.download_button(
Â  Â  Â  Â  Â  Â  label="ğŸ’¾ Spektrum als CSV",
Â  Â  Â  Â  Â  Â  data=export_df.to_csv(index=False).encode('utf-8'),
Â  Â  Â  Â  Â  Â  file_name="sdris_vacuum_spectrum.csv",
Â  Â  Â  Â  Â  Â  mime="text/csv"
Â  Â  Â  Â  )
